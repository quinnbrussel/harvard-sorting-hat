Quinn Brussel and Henry Weiland's (I) final project works by implementing multipe algorithims that sorts a user into a Harvard freshman dorm based on their personality traits. The program utilizes a collection of HTML pages with flask along with back-end Python to create a website of multiple forms that enables the user to take the quiz.

The program is chiefly contained in app.py, which has the Python that directs the user to their respective pages. The beginning of app.py imports os (essential to the program). The helpers file contains the load_results function which takes a dorm name and returns the dorm name, description, and image, which are sent via jinja to the results page. The function loads names.csv. It removes splits the file on "," using row.split. Now, we have a dictionary, links, which is queried into, using the command line argument, for the dorm name, description, and image. The load_results function is utilized in the form two, three, four, and five routes to send the quiz results to the results HTML page so it can be printed at the end. The header file imports a plethora of global variables, questions, images, and answers that are stored in various dictionaries to prevent clutter in app.py.

The index function has both a GET and POST method, it acts as the homepage when the user first navigates to the website using flask run. First, all the variables utilized are reset using the var_reset function that is defined at the end of app.py. var_reset sets all of the global variables and re-establishes the dictionaries with their original values. If the method is GET, the user is redirected back to the homepage. If the method is POST, the user is directed to the start of the quiz, via /form_one, by clicking the "Get Started" button on the homepage.

The HTML pages correspond directly with each of the functions defined in app.py. While each function sorts the user into a dorm, the respective HTML pages contain the questions and possible answers that are prompted to the user.

In /form_one, all of the necessary global variables are called on (boujee, social, counter, first_images) and all of respective questions are retrieved using question.key()[counter] and the answers by querying questions[question]. If the request.method is GET a page with a quesiton, images, and possible answers is rendered using jinja. When the method is POST, the users's response is evaluated and the page is recursively reloaded with new information (unluess we are out of quesitons, in which case, the next function is called). The user is prompted with 10 questions that initially sorts them into a Boujee category and then a Social category. The first 5 questions increment the boujee variable if the request.form is 1 (indicating the top answer on the HTML page). The next five questions increments the social variable if the request.form is 1 (indicating the top answer on the HTML page). For each question asked, another HTML form is loaded with the counter then set to 0 at the end. The user is then sorted into one of four categories: Boujee-Social (both boujee and social index is above 2/5), Boujee Non-Social (boujee is above 2/5 but social is below 3/5), Non-Boujee social (boujee is below 3/5 but social is above 2/5), and Non-Boujee Non-Social (both boujee and social are below 3/5). With this sorting, the user is then redirected to one of the following:

/form_two: Boujee Social (possible options of Inn or DeWolfe)
/form_three: Boujee Non-Social (possible options of Apley Court, the Prescotts, or Mass Hall)
/form_four: Non-Boujee Social (possible options of Matthews, Thayer, Grays, Strauss, Holworthy or Boston University)
/form_five: Non-Boujee Non-Social (possible options of Canaday, Hurlbut, Greenough, Penny, Weld, Wigg, Hollis, Stoughton, Lionel-Mower, or The University of Chicago).

In /form_two, the function again calls variables that are used along with the respective questions and answers that are pertinent to the /form_two Boujee Social category. If the method is GET, questions and answers are loaded onto the page via jinja. This section loads 5 questions, and if the first option is selected using request.form, a point is added to the Inn index (counter is incremented to continue to load the form). If the Inn has the majority of the points (3/5), the user is redirected to the results page with the load_results passinging informaiton for The Inn. If the Inn does not have a majority of the points, the load_results function passes in information for DeWolfe. 

In /form_three, all of the respective variables, questions, answers, and images are loaded. If the request.form is GET, questions, answers, and images are loaded into the HTML page for /form_three via jinja. For the first three questions, if the first button is pressed, a point is rewarded to the Prescotts. If the Prescott is not selected, points are subtracted from Mass Hall (starts at 3). The first three questions decides between the Prescotts and Apley; if the Prescotts has a majority of the points, then Prescotts moves on to the next round. Vise versa if Apley has the most points. In the next three quesitons, the winner of the first three is compared to Mass Hall, using the same algorithm. Whichever ends up with the most points in the end, is displayed in the results page.

In /form_four, Non-Boujee Social, we have a very different algorithm, as there are more dorms to deal with. This algorithm is essentially a tournament between dorms. View winners_dict in header.py. winners_dict has three keys, the value for which is a list with two dorms. In the first round, we eliminate a dorm from each key in the list. Now winners_dict has three keys, the value of which contains one dorm. In the second round, the first two keys face off, and one is eliminated. We are now down to two keys. In the final round, one of the two remaining keys is eliminated. The final remaining key contains the resulting dorm. This dorm, and its relevant information, is displayed in the results page.

In /form_five, Non-Boujee Non-Social, The algorithm is similar two non-boujee social (ns), but more complex. View winners_five_one and winners_five_two in header.py. We essentially execute the algorithm in Non-Boujee Non-Social twice, resulting in two winners. We then have the two winners face off in a final round. The final element left is loaded into the results page with relevant information.

